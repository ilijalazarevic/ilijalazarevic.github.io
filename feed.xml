<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://ilijalazarevic.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ilijalazarevic.com/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2023-10-02T21:21:43+02:00</updated><id>https://ilijalazarevic.com/feed.xml</id><title type="html">Ilija Lazarevic</title><subtitle>My personal blog where I share my posts about artificial intelligence, machine learning and data science, programming, and various thoughts.</subtitle><author><name>Ilija Lazarevic</name></author><entry><title type="html">Advanced Python: Dot operator</title><link href="https://ilijalazarevic.com/post-advanced-python-dot-operator/" rel="alternate" type="text/html" title="Advanced Python: Dot operator" /><published>2023-10-01T07:14:21+02:00</published><updated>2023-10-01T07:14:21+02:00</updated><id>https://ilijalazarevic.com/post-advanced-python-dot-operator</id><content type="html" xml:base="https://ilijalazarevic.com/post-advanced-python-dot-operator/"><![CDATA[<p>Once again, I will write about something seemingly trivial. It is the “dot operator”. Most of you have already used this operator many times, without knowing or questioning what happens behind the scenes. And in comparison to the concept of metaclasses that I talked about last time, this one is a bit more usable for daily tasks. Just kidding, you are practically using it each time you use Python for something more than a “hello world”.</p>

<p>So what is a “dot operator”? Here is an example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hello</span> <span class="o">=</span> <span class="s">'Hello world!'</span>

<span class="k">print</span><span class="p">(</span><span class="n">hello</span><span class="p">.</span><span class="n">upper</span><span class="p">())</span>
<span class="c1"># Hello world!
</span></code></pre></div></div>

<p>Well this is surely a “hello world” example, but I can hardly imagine someone started teaching you Python exactly like this. Anyway, the “dot operator” is the part <code class="language-plaintext highlighter-rouge">hello.upper()</code>. Let’s try giving a more verbose example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>

    <span class="n">num_of_persons</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hey! I'm </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s">'John'</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">shout</span><span class="p">()</span>
<span class="c1"># Hey I'm John.
</span>
<span class="n">p</span><span class="p">.</span><span class="n">num_of_persons</span>
<span class="c1"># 0
</span>
<span class="n">p</span><span class="p">.</span><span class="n">name</span>
<span class="c1"># 'John'
</span></code></pre></div></div>

<p>There are a few places where you use the “dot operator”. To make it easier to see the bigger picture, let’s summarize the way you use it in two cases:</p>

<ul>
  <li>use it to access attributes of an object or class,</li>
  <li>use it to access functions defined in the class definition.</li>
</ul>

<p>Obviously, we have all of this in our example, and this seems intuitive and as expected. But there is more to this than meets the eye! Take a closer look at this example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="p">.</span><span class="n">shout</span>
<span class="c1"># &lt;bound method Person.shout of &lt;__main__.Person object at 0x1037d3a60&gt;&gt;
</span>
<span class="nb">id</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">shout</span><span class="p">)</span>
<span class="c1"># 4363645248
</span>
<span class="n">Person</span><span class="p">.</span><span class="n">shout</span>
<span class="c1"># &lt;function __main__.Person.shout(self)&gt;
</span>
<span class="nb">id</span><span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="n">shout</span><span class="p">)</span>
<span class="c1"># 4364388816
</span></code></pre></div></div>

<p>Somehow, <code class="language-plaintext highlighter-rouge">p.shout</code> is not referencing the same function as <code class="language-plaintext highlighter-rouge">Person.shout</code> although it should. At least you would expect it, right? And <code class="language-plaintext highlighter-rouge">p.shout</code> is not even a function! Let’s go over the next example before we start discussing what is happening.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>

    <span class="n">num_of_persons</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hey! I'm </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">."</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s">'John'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">shout_v2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Hey, what's up?"</span><span class="p">)</span>

<span class="nb">vars</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># {'name': 'John'}
</span>
<span class="n">p</span><span class="p">.</span><span class="n">shout_v2</span> <span class="o">=</span> <span class="n">shout_v2</span>

<span class="nb">vars</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># {'name': 'John', 'shout_v2': &lt;function __main__.shout_v2(self)&gt;}
</span>
<span class="n">p</span><span class="p">.</span><span class="n">shout</span><span class="p">()</span>
<span class="c1"># Hey, I'm John.
</span>
<span class="n">p</span><span class="p">.</span><span class="n">shout_v2</span><span class="p">()</span>
<span class="c1"># TypeError: shout_v2() missing 1 required positional argument: 'self'
</span></code></pre></div></div>

<p>For those unaware of the <code class="language-plaintext highlighter-rouge">vars</code> function, it returns the dictionary that holds attributes of an instance. If you run <code class="language-plaintext highlighter-rouge">vars(Person)</code> you will get a bit different response, but you will get the picture. There will be both attributes with their values and variables that hold class function definitions. There is obviously a difference between an object that is an instance of a class and the class object itself, and so there will be a difference in <code class="language-plaintext highlighter-rouge">vars</code> function response for these two.</p>

<p>Now, it is perfectly valid to additionally define a function after an object is created. This is the line <code class="language-plaintext highlighter-rouge">p.shout_v2 = shout_v2</code>. This does introduce another key-value pair in the instance dictionary. Seemingly everything is good and we will be able to run smoothly, like <code class="language-plaintext highlighter-rouge">shout_v2</code> was specified in the class definition. But alas! Something is truly wrong. We are not able to call it the same way as we did the <code class="language-plaintext highlighter-rouge">shout</code> method.</p>

<p>Astute readers should have noticed by now how carefully I use the terms <em>function</em> and <em>method</em>. After all, there is a difference in how Python prints these as well. Take a look at the previous examples. <code class="language-plaintext highlighter-rouge">shout</code> is a method, <code class="language-plaintext highlighter-rouge">shout_v2</code> is a function. At least if we look at these from the perspective of the object <code class="language-plaintext highlighter-rouge">p</code>. If we change the perspective and look at these from the perspective of the <code class="language-plaintext highlighter-rouge">Person</code> class, <code class="language-plaintext highlighter-rouge">shout</code> is a function, and <code class="language-plaintext highlighter-rouge">shout_v2</code> doesn’t exist. It is defined only in the object dictionary (namespace). So if you are really going to rely on object-oriented paradigm and mechanisms like encapsulation, inheritance, abstraction, and polymorphism, you will not define functions on objects, like <code class="language-plaintext highlighter-rouge">p</code> is in our example. You will make sure you are defining functions in a class definition (body).</p>

<p>So why are these two different, and why do we get the error? Well, the fastest answer is because of the “dot operator”. The longer answer is that there is a mechanism behind the scenes that does the (attribute) name resolution for you. This mechanism consists of <code class="language-plaintext highlighter-rouge">__getattribute__</code> and <code class="language-plaintext highlighter-rouge">__getattr__</code> dunder methods.</p>

<h2 id="getting-the-attributes">Getting the attributes</h2>

<p>At first, this will probably sound unintuitive and rather unnecessarily complicated, but bear with me. Essentially, there are two scenarios that can happen when you try to access an attribute of an object in Python: either there is an attribute or there is not. Simply. In both cases, <code class="language-plaintext highlighter-rouge">__getattribute__</code> is called, or to make it easier for you, it is <strong>being called always</strong>. This method:</p>

<ul>
  <li>returns computed attribute value,</li>
  <li>explicitly calls <code class="language-plaintext highlighter-rouge">__getattr__</code>, or</li>
  <li>raises <code class="language-plaintext highlighter-rouge">AttributeError</code> in which case <code class="language-plaintext highlighter-rouge">__getattr__</code> is called by default.</li>
</ul>

<p>If you want to intercept the mechanism that resolves attribute names, this is the place to hijack. You just have to be careful, because it is really easy to end up in an infinite loop or to mess up the whole mechanism of name resolution, especially in the scenario of object-oriented inheritance. It is not as simple as it may appear.</p>

<p>If you want to handle cases where there is no attribute in the object’s dictionary, you can straight away implement the <code class="language-plaintext highlighter-rouge">__getattr__</code> method. This one gets called when <code class="language-plaintext highlighter-rouge">__getattribute__</code> fails to access the attribute name. If this method can’t find an attribute or deal with a missing one after all, it raises an <code class="language-plaintext highlighter-rouge">AttributeError</code> exception as well. Here is how you can play around with these:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>

    <span class="n">num_of_persons</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hey! I'm </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">."</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'getting the attribute name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">().</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'this attribute doesn</span><span class="se">\'</span><span class="s">t exist: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
        <span class="k">raise</span> <span class="nb">AttributeError</span><span class="p">()</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s">'John'</span><span class="p">)</span>

<span class="n">p</span><span class="p">.</span><span class="n">name</span>
<span class="c1"># getting the attribute name: name
# 'John'
</span>
<span class="n">p</span><span class="p">.</span><span class="n">name1</span>
<span class="c1"># getting the attribute name: name1
# this attribute doesn't exist: name1
#
# ... exception stack trace
# AttributeError:
</span></code></pre></div></div>

<p>It is very important to call <code class="language-plaintext highlighter-rouge">super().__getattribute__(...)</code> in your implementation of <code class="language-plaintext highlighter-rouge">__getattribute__</code> and the reason, like I wrote earlier, is that there is a lot going on in Python’s default implementation. And this is exactly the place where “dot operator” gets its magic from. Well, at least half of the magic is there. The other part is in how a class object is created after interpreting the class definition.</p>

<h2 id="class-functions">Class functions</h2>

<p>The term I use here is purposeful. Class does contain only <em>functions</em>, and we saw this in one of the first examples:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="p">.</span><span class="n">shout</span>
<span class="c1"># &lt;bound method Person.shout of &lt;__main__.Person object at 0x1037d3a60&gt;&gt;
</span>
<span class="n">Person</span><span class="p">.</span><span class="n">shout</span>
<span class="c1"># &lt;function __main__.Person.shout(self)&gt;
</span></code></pre></div></div>

<p>It is the object that has methods. The process of transforming the function in a class into a method of an object is called bounding, and the result is what you see in the previous example, a <em>bound method</em>. What makes it <em>bound</em>, and to what? Well, once you have an instance of a class and start calling its methods, you are, in essence, passing the object reference to each of its methods. It is called <code class="language-plaintext highlighter-rouge">self</code>. So, how does this happen, and who does it?</p>

<p>Well, the first part happens when the class body is being interpreted. There are quite a few things that happen in this process, like defining a class namespace, adding attribute values to it, defining (class) functions, and binding them to their names. Now, as these functions are being defined, they are being wrapped in a way. Wrapped in an object conceptually called <strong><em>descriptor</em></strong>. This <em>descriptor</em> is enabling this change in the identification and behavior of class functions that we saw previously. I’ll make sure to write a separate blog post about <em>descriptors</em>, but for now, know that this object is an instance of a class that implements a predefined set of dunder methods. This is also called a <em>Protocol</em>. Once these are implemented, objects of this class are expected to behave in a specific way. There is a difference between the <strong>data</strong> and <strong>non-data</strong> descriptors. Former implements <code class="language-plaintext highlighter-rouge">__get__</code>, <code class="language-plaintext highlighter-rouge">__set__</code>, and <code class="language-plaintext highlighter-rouge">__delete__</code> dunder methods. Later, it implements only the <code class="language-plaintext highlighter-rouge">__get__</code> method. Anyway, each function in a class ends up wrapped in a so-called <strong>non-data</strong> descriptor.</p>

<p>Once you initiate attribute lookup by using the “dot operator”, the <code class="language-plaintext highlighter-rouge">__getattribute__</code> method is called, and the whole process of scanning starts. This process stops when resolution is successful, and it goes something like this:</p>

<ol>
  <li>return the data descriptor that has the desired name, or</li>
  <li>return instance attribute with the desired name, or</li>
  <li>return non-data descriptor with the desired name, or</li>
  <li>return class attribute with the desired name, or</li>
  <li>raise <code class="language-plaintext highlighter-rouge">AttributeError</code> that essentially calls the <code class="language-plaintext highlighter-rouge">__getattr__</code> method.</li>
</ol>

<p>I’ll leave a link to official documentation on the Python implementation of this mechanism. I highly advise you to go and try understanding the whole logic behind it.</p>

<p>The important thing here is that each class function (which is an object) gets wrapped in a non-data descriptor (which is a function), and this means that this wrapper object has the <code class="language-plaintext highlighter-rouge">__get__</code> dunder method defined. What this dunder method does is return a new callable (think of it as a new function), where the first argument is the reference to the object on which we are performing the “dot operator”. I said to think about it as a new function since it is a callable. In essence, it is another object called <code class="language-plaintext highlighter-rouge">MethodType</code>. Check it out:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">shout</span><span class="p">)</span>
<span class="c1"># getting the attribute name: shout
# method
</span>
<span class="nb">type</span><span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="n">shout</span><span class="p">)</span>
<span class="c1"># function
</span></code></pre></div></div>

<p>One interesting thing certainly is that this type of class function is <code class="language-plaintext highlighter-rouge">function</code>. And this type is exactly the wrapper object that defines the <code class="language-plaintext highlighter-rouge">__get__</code> method. However, once we try to access it as method <code class="language-plaintext highlighter-rouge">shout</code> by “dot operator”, <code class="language-plaintext highlighter-rouge">__getattribute__</code> iterates through the list and stops at the third case (return non-data descriptor). This <code class="language-plaintext highlighter-rouge">__get__</code> method contains additional logic that takes the object’s reference and creates <code class="language-plaintext highlighter-rouge">MethodType</code> with reference to the function and object.</p>

<p>Here is the official documentation mockup:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Function</span><span class="p">:</span>
    <span class="p">...</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
</code></pre></div></div>

<p>And MethodType just keeps these references and implements a callable protocol. Here is the official documentation mockup:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MethodType</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__func__</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__self__</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">__func__</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">__self__</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></div>

<p>In the end, it should be clear why we make a distinction between functions and methods and how functions get bound once they are accessed through objects and the “dot operator”. If you think about it, we would be perfectly okay with invoking class functions in the next way:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>

    <span class="n">num_of_persons</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hey! I'm </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">."</span><span class="p">)</span>
        
<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s">'John'</span><span class="p">)</span>

<span class="n">Person</span><span class="p">.</span><span class="n">shout</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># Hey! I'm John.
</span></code></pre></div></div>

<p>Yet, this really is not the advised way, and is just plain ugly. Usually you will not have to do this in your code. And this concludes what I wanted to write in this article. Descriptors are next, since it is so important concept.</p>

<p>Until then, best of luck paving your way into the land of Python.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://docs.python.org/3/howto/descriptor.html#id17">Invocation from an instance</a></li>
  <li><a href="https://docs.python.org/3/howto/descriptor.html#id25">Functions and methods</a></li>
</ul>

<p>Here is one random Midjourney art for you persistent enough!</p>

<p><img src="../assets/img/bar_room_man_playing_piano_pulp_noir_header.png" alt="Hey, this is the wrong keyboard!" /></p>]]></content><author><name>Ilija Lazarevic</name></author><category term="python" /><category term="oop" /><category term="advanced" /><summary type="html"><![CDATA[Dot operator in Python is probably always overlooked, but it holds crucial mechanism for object-oriented programming.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ilijalazarevic.com/assets/img/bar_room_man_playing_piano_pulp_noir_header.png" /><media:content medium="image" url="https://ilijalazarevic.com/assets/img/bar_room_man_playing_piano_pulp_noir_header.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Advanced Python: Metaclasses</title><link href="https://ilijalazarevic.com/post-advanced-python-metaclasses/" rel="alternate" type="text/html" title="Advanced Python: Metaclasses" /><published>2023-09-06T07:14:21+02:00</published><updated>2023-09-06T07:14:21+02:00</updated><id>https://ilijalazarevic.com/post-advanced-python-metaclasses</id><content type="html" xml:base="https://ilijalazarevic.com/post-advanced-python-metaclasses/"><![CDATA[<p>This article is purposefully going to be a bit advanced and there is at least two reasons.</p>

<p>For one, the basic intros are already available everywhere, and it is a path walked a million times. For the reader who is trying to get things done in Python that will be more than enough.</p>

<p>For two, more advanced talks about OOP mostly go in the direction of describing encapsulation, abstraction, inheritance and polymorphism, and how to use them in numerous design patterns guided by some of the principles in software engineering (for example <em>SOLID</em>).</p>

<p>Now, my idea is to briefly write about how Python enables OOP paradigm. In essence, what is behind these lines of code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">child</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span>
</code></pre></div></div>

<p>Back in the days when you learned about object-oriented programming, you most probably came across a general idea that describes what classes and objects are, and it goes like this:</p>

<blockquote>
  <blockquote>
    <p>“Class is like a cookie mold. And objects are cookies molded by it”.</p>
  </blockquote>
</blockquote>

<p>This is a very intuitive explanation and conveys the idea rather clearly. Having said that, our example defines two templates with little or no functionalities, but they work. You can play with defining the <code class="language-plaintext highlighter-rouge">__init__</code> method, set some object attributes, and make it more usable. However, what is interesting <strong>in Python</strong> is that <strong>even though a class is a “template” that is used to create objects from it, it is also an object itself.</strong> Everyone learning OOP in Python would quickly go over this statement, not really thinking in depth. Everything in Python is an object, so what? But once you start thinking about this, a lot of questions pop up, and interesting Python intricacies unravel.</p>

<p>Before I start asking these questions for you, let’s remember that <strong>in Python, everything is an object</strong>. And I mean everything. This is probably something you already picked up, even if you are a newbie. The next example shows this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">id</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span> 
<span class="c1"># some memory location
</span>
<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="nb">id</span><span class="p">(</span><span class="n">Child</span><span class="p">)</span>
<span class="c1"># some memory location
</span>
<span class="c1"># Class objects are created, you can instantiate objects
</span>
<span class="n">child</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span>
<span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="c1"># some memory location
</span></code></pre></div></div>

<p>Based on these examples, here are some questions that you should ask yourself:</p>

<ul>
  <li>If a class is an object, when is it created?</li>
  <li>Who creates class objects?</li>
  <li>If class is an object, how come I’m able to call it when instantiating an object?</li>
</ul>

<h2 id="class-object-creation">Class object creation</h2>

<p>Python is widely known as an interpreted language. This means there is an interpreter (program or process) that goes line by line and tries to translate it to machine code. This is opposed to compiled programming languages like C, where programming code is translated into machine code before you run it. This is a very simplified view. To be more precise, Python is both compiled and interpreted, but this is a subject for another time. What is important for our example is that the interpreter goes through the class definition, and once the class code block is finished, the class object is created. From then on, you are able to instantiate objects from it. You have to do this explicitly of course, even though class objects are instantiated implicitly.</p>

<p>But what “process” is triggered when the interpreter finishes reading the class code block? We could go directly to details, but one chart speaks a thousand words:</p>

<p><img src="../assets/img/chart_metaclass.png" alt="" /></p>

<p>If you are not aware, Python has <code class="language-plaintext highlighter-rouge">type</code> functions that can be used for our purpose(s) now. By calling <code class="language-plaintext highlighter-rouge">type</code> with object as an argument, you will get object’s type. How ingenious! Take a look:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">child</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span>

<span class="nb">type</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="c1"># Child
</span>
<span class="nb">type</span><span class="p">(</span><span class="n">Child</span><span class="p">)</span>
<span class="c1"># type
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">type</code> call in the example makes sense. <code class="language-plaintext highlighter-rouge">child</code> is of type <code class="language-plaintext highlighter-rouge">Child</code>. We used a class (object) to create it. So in some way, you can think of <code class="language-plaintext highlighter-rouge">type(child)</code> giving you the name of its “creator”. And in a way, <code class="language-plaintext highlighter-rouge">Child</code> class is its creator because you called it to create a new instance. But what happens when you try to get the “creator” of the class object, <code class="language-plaintext highlighter-rouge">type(Child)</code>? You get <code class="language-plaintext highlighter-rouge">type</code>. To sum it up, <strong>object is an instance of a class, and a class is an instance of a type</strong>. By now you may be wondering how a class is an instance of a function, and the answer is: <code class="language-plaintext highlighter-rouge">type</code> is both a function and a class. This is intentionally left as it is because of backward compatibility back in the old days.</p>

<p>What will make your head spin is the name we have for classes that are used to create class objects. It is <strong>metaclasses.</strong> And here it is important to make a distinction between inheritance from the perspective of the object-oriented paradigm and the mechanisms of a language that enable you to practice this paradigm. Metaclasses provide this mechanism. What can be even more confusing is that metaclasses are able to inherit parent classes just like regular ones can. But this can quickly become “inceptional” programming, so let’s not go that deep.</p>

<p>Do we have to deal with these metaclasses on a daily basis? Well, no. In rare cases, you need to define and use them because, most of the time, default behavior is just fine.</p>

<p>Let’s continue with our journey, this time with a new example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

<span class="n">parent</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="s">'John'</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
</code></pre></div></div>

<p>Something like this should be your very first OOP step in Python. You are taught that <code class="language-plaintext highlighter-rouge">__init__</code> is a constructor, where you set the values of your object attributes, and you are good to go. However, this <code class="language-plaintext highlighter-rouge">__init__</code> dunder method is exactly what it says: the initialization step. Isn’t it strange that you call it to initialize an object, and yet you get an object instance in return? There is no <code class="language-plaintext highlighter-rouge">return</code> in this method. So, how is this possible? Who returns the instance of a class?</p>

<p>Very few learn at the start of their Python journey that there is another method that is called implicitly and is named <code class="language-plaintext highlighter-rouge">__new__</code>. This method actually creates an instance before <code class="language-plaintext highlighter-rouge">__init__</code> is called to initialize it. Here is an example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'new is called'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">().</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'init is called'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

<span class="n">parent</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="s">'John'</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="c1"># new is called
# init is called
</span></code></pre></div></div>

<p>What you’ll immediately see is that <code class="language-plaintext highlighter-rouge">__new__</code> returns <code class="language-plaintext highlighter-rouge">super().__new__(cls)</code>. This is a new instance. <code class="language-plaintext highlighter-rouge">super()</code> fetches the parent class of <code class="language-plaintext highlighter-rouge">Parent</code> which is implicitly <code class="language-plaintext highlighter-rouge">object</code> class. This class is inherited by all classes in Python. And is an object in itself too. Another innovative move by the Python creators!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="c1"># True
</span></code></pre></div></div>

<p>But what binds <code class="language-plaintext highlighter-rouge">__new__</code> and <code class="language-plaintext highlighter-rouge">__init__</code>? There has to be something more to how object instantiation is performed when we call <code class="language-plaintext highlighter-rouge">Parent('John' ,35)</code>. Take a look at it once again. You are invoking (calling) a class object, like a function.</p>

<h2 id="python-callable">Python callable</h2>

<p>Python, being a structurally typed language, enables you to define specific methods in your class that describe a Protocol (a way of using its object), and based on this, all instances of a class will behave in the expected way. Do not get intimidated if you are coming from other programming languages. Protocols are something like Interfaces in other languages. However, here we do not explicitly state that we are implementing a specific interface and, therefore, specific behavior. We just implement methods that are described by Protocol, and all objects are going to have that behavior. One of these Protocols is <em>Callable</em>. By implementing dunder method <code class="language-plaintext highlighter-rouge">__call__</code> you enable your object to be called like a function. See the example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'new is called'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">().</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'init is called'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Parent here!'</span><span class="p">)</span>

<span class="n">parent</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="s">'John'</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="n">parent</span><span class="p">()</span>
<span class="c1"># Parent here!
</span></code></pre></div></div>

<p>By implementing <code class="language-plaintext highlighter-rouge">__call__</code> in the class definition, your class instances become <em>callable</em>. But what about <code class="language-plaintext highlighter-rouge">Parent('John', 35)</code>. How do you achieve the same with your class object? If object’s type definition (class) specifies that it is callable, then the class object type (type i.e. metaclass) should specify that the class object is callable too, right? Invocation of the dunder methods <code class="language-plaintext highlighter-rouge">__new__</code> and <code class="language-plaintext highlighter-rouge">__init__</code> happens there.</p>

<p>At this point, it is time to start playing with metaclasses.</p>

<h2 id="python-metaclasses">Python metaclasses</h2>

<p>There are at least two ways you can change the process of class object creation. One is by using class decorators; the other is by explicitly specifying metalcass. We will describe the metaclass approach. Keep in mind that a metaclass looks like a regular class, and the only exception is that it has to inherit <code class="language-plaintext highlighter-rouge">type</code> class. Why? Because <code class="language-plaintext highlighter-rouge">type</code> class has all the implementation that is required for our code to still work as expected. For example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is called'</span>
              <span class="sa">f</span><span class="s">' with args=</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s">, kwargs=</span><span class="si">{</span><span class="n">kwarg</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MyMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'new is called'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">().</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'init is called'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

<span class="n">parent</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="s">'John'</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="c1"># Parent is called with args=('John', 35), kwargs={}
</span><span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># NoneType
</span></code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">MyMeta</code> is the drive force behind new class object instantiation and also specifies how new class instances are created. Take a closer look at the last two lines of the example. <code class="language-plaintext highlighter-rouge">parent</code> holds nothing! But why? Because, as you can see, <code class="language-plaintext highlighter-rouge">MyMeta.__call__</code> just prints information and returns nothing. Explicitly, that is. Implicitly, that means that it returns <code class="language-plaintext highlighter-rouge">None</code>, which is of <code class="language-plaintext highlighter-rouge">NoneType</code>.</p>

<p>How should we fix this?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">cls</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is called'</span>
              <span class="sa">f</span><span class="s">'with args=</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s">, kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'metaclass calls __new__'</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">cls</span><span class="p">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'metaclass calls __init__'</span><span class="p">)</span>
            <span class="n">cls</span><span class="p">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MyMeta</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'new is called'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">().</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'init is called'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

<span class="n">parent</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="s">'John'</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="c1"># Parent is called with args=('John', 35), kwargs={}
# metaclass calls __new__
# new is called
# metaclass calls __init__
# init is called
</span>
<span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># Parent
</span>
<span class="nb">str</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="c1"># '&lt;__main__.Parent object at 0x103d540a0&gt;'
</span></code></pre></div></div>

<p>From the output, you can see what happens on <code class="language-plaintext highlighter-rouge">MyMeta.__call__</code>invocation. The provided implementation is just an example of how the whole thing works. You should be more careful if you plan to override parts of metaclasses yourself. There are some edge cases that you have to cover up. For example, one of the edge cases is that <code class="language-plaintext highlighter-rouge">Parent.__new__</code> can return an object that is not an instance of the <code class="language-plaintext highlighter-rouge">Parent</code> class. In that case, it is not going to be initialized by <code class="language-plaintext highlighter-rouge">Parent.__init__</code> method. That is the expected behavior you have to be aware of, and it really doesn’t make sense to initialize an object that is not an instance of the same class.</p>

<p>Anyway, this would conclude the overview of what happens when you define a class and make an instance of it. Of course, you could go even further and see what happens during the class block interpretation. All of this happens in the metaclass too.</p>

<p>Maybe I’ll write about it some time in the future. Until then, best of luck learning Python!</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://jfreeman.dev/blog/2020/12/07/python-metaclasses/">Python Metaclasses</a></li>
  <li><a href="https://www.honeybadger.io/blog/python-instantiation-metaclass/">Understanding Object Instantiation and Metaclasses in Python</a></li>
</ul>

<p>Here is one random Midjourney art for you persistent enough!</p>

<p><img src="../assets/img/timeleviathan_locked_up_inside_you.png" /></p>]]></content><author><name>Ilija Lazarevic</name></author><category term="python" /><category term="oop" /><category term="advanced" /><summary type="html"><![CDATA[Metaclasses in Python are advanced concepts, but let's see if we can unpack the complexity.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ilijalazarevic.com/assets/img/timeleviathan_locked_up_inside_you_header.png" /><media:content medium="image" url="https://ilijalazarevic.com/assets/img/timeleviathan_locked_up_inside_you_header.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Advanced Python: Functions</title><link href="https://ilijalazarevic.com/post-advanced-python-functions/" rel="alternate" type="text/html" title="Advanced Python: Functions" /><published>2023-08-01T07:14:21+02:00</published><updated>2023-08-01T07:14:21+02:00</updated><id>https://ilijalazarevic.com/post-advanced-python-functions</id><content type="html" xml:base="https://ilijalazarevic.com/post-advanced-python-functions/"><![CDATA[<p>After reading the title, you probably ask yourself something along the lines of, “Functions in Python are an advanced concept? How? All courses introduce functions as the basic block in language.” And you are right and wrong at the same time.</p>

<p>Most courses on Python introduce functions as a basic concept and building block because, without them, you would not be able to write functional code at all. This is totally different from the functional programming paradigm, which is a separate concept, but I shall touch upon this one too.</p>

<p>Before we delve into the advanced intricacies of Python functions, let’s briefly go over some basic concepts and things you probably already know.</p>

<h1 id="brief-basics">Brief basics</h1>

<p>So you start writing your program, and at some point you end up writing the same sequence of code. You start repeating yourself and the code blocks. This proves to be a good time and place to introduce functions. At least, that is. In Python, you define a function as:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Hey! My name is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">.'</span><span class="p">)</span> 
</code></pre></div></div>

<p>In the world of software engineering, we make a distinction between parts of function definition:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">def</code> - Python keyword used to define a function.</li>
  <li><code class="language-plaintext highlighter-rouge">shout</code> - function name.</li>
  <li><code class="language-plaintext highlighter-rouge">shout(name)</code>- function declaration.</li>
  <li><code class="language-plaintext highlighter-rouge">name</code> - function argument.</li>
  <li><code class="language-plaintext highlighter-rouge">print(...)</code>is a part of a function body or how we call it function definition.</li>
</ul>

<p>A function can return a value or have no return value at all, like the one we previously defined. When function returns value it can return one or more of them:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">break_sentence</span><span class="p">(</span><span class="n">sentence</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sentence</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
</code></pre></div></div>

<p>What you get as a result is a tuple that you can unpack or pick any of the tuple elements to proceed with.</p>

<p>For those of you who are not informed, functions in Python are <strong>first-class citizens</strong>. What does this mean? It means you can work with functions as you would with any other variable. You can pass them as arguments to other functions, return them from functions, and even store them in variables. Here is one of the examples:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">'Hey! My name is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">.'</span>

<span class="c1"># we will use break_sentence defined above
</span>
<span class="c1"># assign function to another variable
</span><span class="n">another_breaker</span> <span class="o">=</span> <span class="n">break_sentence</span> 

<span class="n">another_breaker</span><span class="p">(</span><span class="n">shout</span><span class="p">(</span><span class="s">'John'</span><span class="p">))</span>
<span class="c1"># ['Hey!', 'My', 'name', 'is', 'John.']
</span>
<span class="c1"># Woah! Yes, this is a valid way to define function
</span><span class="n">name_decorator</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">'-'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

<span class="n">name_decorator</span><span class="p">(</span><span class="s">'John'</span><span class="p">)</span>
<span class="c1"># 'J-o-h-n'
</span></code></pre></div></div>

<p>Wait, what was this <code class="language-plaintext highlighter-rouge">lambda</code> ? This is another way you can define functions in Python. This is the so-called unnamed or anonymous function. Well, in this example, we are assigning it to a variable named <code class="language-plaintext highlighter-rouge">name_decorator</code> but you can pass the <code class="language-plaintext highlighter-rouge">lambda</code> expression as an argument of another function without the need to name it. I will cover this shortly.</p>

<p>What is left is to give an example of how functions can be passed as arguments or returned as values from another function. This is the part where we are moving toward advanced concepts, so bear with me.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dash_decorator</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">'-'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">no_decorator</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">name</span>

<span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">decorator</span><span class="o">=</span><span class="n">no_decorator</span><span class="p">):</span>
    <span class="n">decorated_name</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">'Hey! My name is </span><span class="si">{</span><span class="n">decorated_name</span><span class="si">}</span><span class="s">'</span>

<span class="n">shout</span><span class="p">(</span><span class="s">'John'</span><span class="p">)</span>
<span class="c1"># 'Hey! My name is John'
</span>
<span class="n">shout</span><span class="p">(</span><span class="s">'John'</span><span class="p">,</span> <span class="n">decorator</span><span class="o">=</span><span class="n">dash_decorator</span><span class="p">)</span>
<span class="c1"># 'Hey! My name is J-o-h-n'
</span></code></pre></div></div>

<p>So this is how it looks to pass functions as arguments to another function. What about the <code class="language-plaintext highlighter-rouge">lambda</code> function? Well, take a look at the next example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">decorator</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">decorated_name</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">'Hey! My name is </span><span class="si">{</span><span class="n">decorated_name</span><span class="si">}</span><span class="s">'</span>

<span class="k">print</span><span class="p">(</span><span class="n">shout</span><span class="p">(</span><span class="s">'John'</span><span class="p">))</span>
<span class="c1"># Hey! My name is John
</span>
<span class="k">print</span><span class="p">(</span><span class="n">shout</span><span class="p">(</span><span class="s">'John'</span><span class="p">,</span> <span class="n">decorator</span><span class="o">=</span><span class="n">dash_decorator</span><span class="p">))</span>
<span class="c1"># Hey! My name is J-o-h-n
</span></code></pre></div></div>

<p>Now the default decorating function is <code class="language-plaintext highlighter-rouge">lambda</code> and returns the argument’s value as it is (idempotent). Here, it is anonymous because there is no name attached to it.</p>

<p>Notice that <code class="language-plaintext highlighter-rouge">print</code> is also a function, and we are passing a function <code class="language-plaintext highlighter-rouge">shout</code> inside of it as an argument. In essence, we are chaining functions. And this can lead us to a functional programming paradigm, which is a path that you can choose in Python. I will try to write another blog post specifically on this subject because it is very interesting to me. For now, we will keep to the procedural programming paradigm; that is, we will continue with what we have been doing so far.</p>

<p>As stated previously, a function can be assigned to a variable, passed as an argument to another function, and returned from that function. I have shown you some simple examples for the first two cases, but what about returning a function from a function? At first I wanted to keep it really simple, but then again, this is an Advanced Python blog post series!</p>

<h1 id="intermediate-or-advanced-parts">Intermediate or advanced parts</h1>

<p>This will by no means be THE guide to functions and advanced concepts around functions in Python. There are a lot of great materials, which I will leave at the end of this post. However, I want to talk about a couple of interesting aspects that I have found to be very intriguing.</p>

<p>Functions in Python are <strong>objects</strong>. How can we figure this out? Well, each object in Python is an instance of a class that eventually inherits from one specific class called <code class="language-plaintext highlighter-rouge">type</code>. The details of this are convoluted, but to be able to see what this has to do with functions, here is an example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">type</span><span class="p">(</span><span class="n">shout</span><span class="p">)</span>
<span class="c1"># function
</span>
<span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">shout</span><span class="p">))</span>
<span class="c1"># type
</span></code></pre></div></div>

<p>When you define a class in Python, it automatically inherits the <code class="language-plaintext highlighter-rouge">object</code> class. And which class does <code class="language-plaintext highlighter-rouge">object</code> inherit?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
<span class="c1"># type
</span></code></pre></div></div>

<p>And should I tell you that classes in Python are objects too? Indeed, this is mind-boggling for beginners. But as Andrew Ng would say, this is not that important; don’t worry about it.</p>

<p>Okay, so functions are objects. Certainly functions should have some magic methods, then, right?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shout</span><span class="p">.</span><span class="n">__class__</span>
<span class="c1"># function
</span>
<span class="n">shout</span><span class="p">.</span><span class="n">__name__</span>
<span class="c1"># shout
</span>
<span class="n">shout</span><span class="p">.</span><span class="n">__call__</span>
<span class="c1"># &lt;method-wrapper '__call__' of function object at 0x10d8b69e0&gt;
# Oh snap!
</span></code></pre></div></div>

<p>The magic method <code class="language-plaintext highlighter-rouge">__call__</code> is defined for objects that are callable. So our <code class="language-plaintext highlighter-rouge">shout</code> object (function) is callable. We can <em>call</em> it with or without arguments. But this is interesting. What we did previously was define a <code class="language-plaintext highlighter-rouge">shout</code> function and get an object that is callable with the <code class="language-plaintext highlighter-rouge">__call__</code> magic method that is a function. Have you ever watched the Inception movie?</p>

<p>So, our <em>function</em> is not really a function but an object. Objects are instances of classes and contain methods and attributes, right? This is something you should know from OOP. How can we find out what the attributes of our object are? There is this Python function called <code class="language-plaintext highlighter-rouge">vars</code> that returns a dictionary of object attributes with their values. Let’s see what happens in the next example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">vars</span><span class="p">(</span><span class="n">shout</span><span class="p">)</span>
<span class="c1"># {}
</span>
<span class="n">shout</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">'Jimmy'</span>

<span class="nb">vars</span><span class="p">(</span><span class="n">shout</span><span class="p">)</span>
<span class="c1"># {'name': 'Jimmy'} 
</span></code></pre></div></div>

<p>This is interesting. Not that you could figure out the use case for this straight away. And even if you could find it, I would highly discourage you from doing this black magic. It’s just not easy to follow, even though it is an interesting flex. The reason I have shown you this is because we wanted proof that functions are indeed objects. Remember, everything in Python is an object. That is how we roll in Python.</p>

<p>Now, long-awaited functions are returning. This concept is also very interesting since it gives you a lot of utility. With a little bit of syntactic sugar, you get very expressive. Let’s dive in.</p>

<p>First, a function’s definition can contain another function’s definition. Even more than one. Here is a perfectly fine example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shout</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_upper_case</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">_upper_case</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<p>If you are thinking that this is just a convoluted version of <code class="language-plaintext highlighter-rouge">name.upper()</code> you are right. But wait, we are getting there.</p>

<p>So, given the previous example, which is fully functional Python code, you can experiment with multiple functions defined inside your function. What is the value of this neat trick? Well, you could be in a situation where your function is huge with repeating blocks of code. This way, defining a <em>subfunction</em> would increase readability. In practice, huge functions are a sign of code smell, and it is highly encouraged to break them into a few smaller ones. So, following this advice, you will rarely have the need to define multiple functions inside each other. One thing to notice is that the <code class="language-plaintext highlighter-rouge">_upper_case</code> function is hidden and out of reach in the scope where the <code class="language-plaintext highlighter-rouge">shout</code> function ends up being defined and available to call. This way, you can’t test it easily, which is yet another issue with this approach.</p>

<p>However, there is one specific case where defining a function inside another is a way to go. This is when you implement the decorator of a function. This has nothing to do with the function we used to decorate the <code class="language-plaintext highlighter-rouge">name</code> string in one of previous examples.</p>

<h1 id="decorators-in-python">Decorators in Python</h1>

<p>What is a <em>decorator function</em>? Think of it as a function that wraps your function. The goal of doing this is to introduce additional functionality to an already existing function. For example, say you want to log every time your function is called:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">my_logger</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is being called!'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fun</span>

<span class="n">my_function</span><span class="p">()</span>
<span class="c1"># 45
</span>
<span class="n">my_logger</span><span class="p">(</span><span class="n">my_function</span><span class="p">)</span>
<span class="c1"># my_function is being called!
# &lt;function my_function at 0x105afbeb0&gt;
</span>
<span class="n">my_logger</span><span class="p">(</span><span class="n">my_function</span><span class="p">)()</span>
<span class="c1"># my_function is being called!
# 45
</span>
</code></pre></div></div>

<p>Pay attention to how we decorate our function; we pass it as an argument to the decorating one. But this is not enough! Remember, decorator returns function, and this function needs to be invoked (called). This is what the last call does.</p>

<p>Now, in practice, what you really want is for decoration to persist under the original function’s name. In our case, we would like that after the interpreter parses our code,  <code class="language-plaintext highlighter-rouge">my_function</code> is the name of the decorated function. This way, we keep things simple to follow, and we are making sure that any part of our code won’t be able to call an undecorated version of our function. Example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">my_logger</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is being called!'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fun</span>

<span class="n">my_function</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">(</span><span class="n">my_function</span><span class="p">)</span>

<span class="n">my_function</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># my_function is being called!
# 45
</span></code></pre></div></div>

<p>You will admit that the part where we reassign the function’s name to a decorated one is troublesome. You have to keep this in mind. If there are many function calls you want to log, there will be a lot of repeating code. Here is where the syntactic sugar comes in. After the decorator function is defined, you can use it to decorate the another function by prefixing the function definition with an <code class="language-plaintext highlighter-rouge">@</code> and the name of the decorator function. Example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_logger</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is being called!'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fun</span>

<span class="o">@</span><span class="n">my_logger</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="n">my_function</span><span class="p">()</span>
<span class="c1"># my_function is being called!
# 45
</span></code></pre></div></div>

<p>This is Python’s Zen. Look at the expressiveness of the code and its simplicity.</p>

<p>One important thing to note here! Even though the output makes sense, it is not what you would expect! At the time of loading your Python code, the interpreter will call the <code class="language-plaintext highlighter-rouge">my_logger</code> function and effectively run it! You will get the log output, yet this will not be what we wanted in the first place. Look at the code now:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_logger</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is being called!'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fun</span>

<span class="o">@</span><span class="n">my_logger</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="n">my_function</span><span class="p">()</span>
<span class="c1"># my_function is being called!
# 45
</span><span class="n">my_function</span><span class="p">()</span>
<span class="c1"># 45
</span></code></pre></div></div>

<p>To be able to run decorator code once the original function is called, we have to wrap it around another function. This is where things can get messy. Here is an example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_logger</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_inner_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is being called!'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_inner_fun</span>

<span class="o">@</span><span class="n">my_logger</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">my_function</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="c1"># my_function is being called!
# 10
</span></code></pre></div></div>

<p>In this example, there are some updates as well, so let’s go over them:</p>
<ol>
  <li>We want to be able to pass the argument to <code class="language-plaintext highlighter-rouge">my_function</code>.</li>
  <li>We want to be able to decorate any function, not just <code class="language-plaintext highlighter-rouge">my_function</code>. Because we don’t know the exact number of arguments for future functions, we have to keep things as general as we can, which is why we use <code class="language-plaintext highlighter-rouge">*args</code> and <code class="language-plaintext highlighter-rouge">**kwargs</code>.</li>
  <li>Most importantly, we defined <code class="language-plaintext highlighter-rouge">_inner_decorator</code> that is going to be called each time we call <code class="language-plaintext highlighter-rouge">my_function</code> in the code. It accepts positional and keyword arguments and passes them as arguments to the decorated function.</li>
</ol>

<p>Always keep in mind that the decorator function has to return a function that accepts the same arguments (number and their respective types) and returns the same output (again, number and their respective types). That is, if you want to make the function user not confused and the code reader not trying to figure out what the hell is happening.</p>

<p>For example, say you have two functions that are different in results but also require arguments:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">my_logger</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="o">@</span><span class="n">my_logger</span>
<span class="k">def</span> <span class="nf">my_unordinary_function</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="n">m</span>

<span class="k">print</span><span class="p">(</span><span class="n">my_function</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="c1"># my_function is being called!
# 10
</span>
<span class="k">print</span><span class="p">(</span><span class="n">my_unordinary_function</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1"># my_unordinary_function is being called!
# 11
</span>
</code></pre></div></div>

<p>In our example, the decorator function accepts just the function it decorates. But what if you wanted to pass additional parameters and dynamically change decorator behavior? Say you want to tune the logger decorator’s verbosity. So far, our decorator function has accepted one argument: the function it decorates. However, when the decorator function has its own arguments, these are passed to it first. Then, the decorator function has to return a function that accepts the decorated one. Essentially, things are getting more convoluted. Remember the movie Inception reference?</p>

<p>Here is an example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">IntEnum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">class</span> <span class="nc">LogVerbosity</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
    <span class="n">ZERO</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LOW</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">MEDIUM</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">HIGH</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">my_logger</span><span class="p">(</span><span class="n">verbosity</span><span class="p">:</span> <span class="n">LogVerbosity</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_inner_logger</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">_inner_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;=</span> <span class="n">LogVerbosity</span><span class="p">.</span><span class="n">LOW</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'LOG: Verbosity level: </span><span class="si">{</span><span class="n">verbosity</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'LOG: </span><span class="si">{</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> is being called!'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;=</span> <span class="n">LogVerbosity</span><span class="p">.</span><span class="n">MEDIUM</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'LOG: Date and time of call is </span><span class="si">{</span><span class="n">datetime</span><span class="p">.</span><span class="n">utcnow</span><span class="p">()</span><span class="si">}</span><span class="s">.'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="n">LogVerbosity</span><span class="p">.</span><span class="n">HIGH</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'LOG: Scope of the caller is </span><span class="si">{</span><span class="n">__name__</span><span class="si">}</span><span class="s">.'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'LOG: Arguments are </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_inner_decorator</span>

    <span class="k">return</span> <span class="n">_inner_logger</span>

<span class="o">@</span><span class="n">my_logger</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="n">LogVerbosity</span><span class="p">.</span><span class="n">LOW</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="o">@</span><span class="n">my_logger</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="n">LogVerbosity</span><span class="p">.</span><span class="n">HIGH</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_unordinary_function</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="n">m</span>

<span class="k">print</span><span class="p">(</span><span class="n">my_function</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="c1"># LOG: Verbosity level: LOW
# LOG: my_function is being called!
# 45
</span>
<span class="k">print</span><span class="p">(</span><span class="n">my_unordinary_function</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1"># LOG: Verbosity level: HIGH
# LOG: my_unordinary_function is being called!
# LOG: Date and time of call is 2023-07-25 19:09:15.954603.
# LOG: Scope of the caller is __main__.
# LOG: Arguments are (5, 1), {}
# 11 
</span></code></pre></div></div>

<p>I won’t go into describing code unrelated to decorator, but I encourage you to look it up and learn. Here we have a decorator that logs function calls with different verbosity. As already described, <code class="language-plaintext highlighter-rouge">my_logger</code> decorator now accepts arguments that dynamically change its behavior. After arguments are passed to it, the resulting function that it returns should accept a function to decorate. This is the <code class="language-plaintext highlighter-rouge">_inner_logger</code> function. By now, you should understand what the rest of the decorator code is doing.</p>

<p>My first idea for this post was to talk about advanced topics for decorators. However, as you probably know by now, I have mentioned and used a lot of advanced topics as well. In future blog posts, I’ll tackle some of these to a certain extent. Nevertheless, my advice for you is to go and learn about the things mentioned here from other sources as well. I hope I have introduced something new for you and that you are now confident about writing functions as an advanced Python programmer.</p>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://realpython.com/primer-on-python-decorators/">Primer on Python decorators</a></li>
  <li><a href="https://realpython.com/inner-functions-what-are-they-good-for/">Python Inner Functions: What Are They Good For?</a></li>
  <li><a href="https://docs.python.org/3/howto/enum.html">Enum HOWTO</a></li>
</ul>]]></content><author><name>Ilija Lazarevic</name></author><category term="python" /><category term="oop" /><category term="advanced" /><summary type="html"><![CDATA[Python functions advanced concepts]]></summary></entry><entry><title type="html">Managing Python Versions and Virtual Environments</title><link href="https://ilijalazarevic.com/post-python-virtual-environments/" rel="alternate" type="text/html" title="Managing Python Versions and Virtual Environments" /><published>2023-07-13T14:21:28+02:00</published><updated>2023-07-13T14:21:28+02:00</updated><id>https://ilijalazarevic.com/post-python-virtual-environments</id><content type="html" xml:base="https://ilijalazarevic.com/post-python-virtual-environments/"><![CDATA[<p>The idea for this blog post is about how Python can be used in different environments. These are so-called “virtual environments” in Python, and there have been many tools that provide this capability with more or less additional functionalities.</p>

<p>Some of you may remember <code class="language-plaintext highlighter-rouge">venv</code> and the <code class="language-plaintext highlighter-rouge">virtualenv</code> as one of the first tools that enabled developers to create specific virtual environments and not pollute the system. However, a lot was left to be desired. So then there were <code class="language-plaintext highlighter-rouge">virtualenvwrapper</code> and <code class="language-plaintext highlighter-rouge">pipenv</code>. These tried to address the lack of usability in some use cases. However, the main points that all of these tools want to address are:</p>

<ol>
  <li>deal with multiple Python interpreter versions,</li>
  <li>where to install a virtual environment, or have some consistent way of doing it,</li>
  <li>how to logically connect the virtual environment with your project if it was installed somewhere else and not in the project directory,</li>
  <li>activate the virtual environment when you are about to work on the project, and then deactivate it,</li>
  <li>keep the lists of installed packages that were used for project development and for using the project as a library in another project,</li>
  <li>how to pack your project and publish it in a consistent way.</li>
</ol>

<p>There is a slight chance I forgot some pain points that developers had to solve. Nevertheless, you can see that there are already enough concerns to deal with once you start working on your Python projects.</p>

<p>Those of you who know what I’m talking about will shout (silently) “Hey, you forgot <code class="language-plaintext highlighter-rouge">pyenv</code> and <code class="language-plaintext highlighter-rouge">poetry</code>!” And you would be wrong, since these two were exactly the reasons why I wanted to write this blog post. And yes, you can use just one of these. However, I like to use them both as complementary tools to achieve all of the previously addressed points in the list above.</p>

<h2 id="pyenv">Pyenv</h2>

<p>This tool is really handy if you want to have more than one Python interpreter version available on your system. I will not go over the installation and basic usage tutorials here. My idea is to give you a general overview of how <code class="language-plaintext highlighter-rouge">pyenv</code> works.</p>

<p>On a vanilla system, you will probably have just one Python interpreter version installed. This will be enough for simple fiddling with Python or even working on your project, as long as the project’s Python version is exactly the same as the one on your system. Of course, you would have to install packages on a system level and pray that you wouldn’t work on two different projects with different sets of packages (and versions) at the same time.</p>

<p>Once you start being more serious with your development and research, you will find yourself using different Python interpreter versions with different sets of packages and their versions on each project. Using system-installed Python will probably get messy, and there is a high chance you will end up “devopsing” your time instead of focusing on Python’s Zen.</p>

<p>Here, <code class="language-plaintext highlighter-rouge">pyenv</code> comes to the rescue. It gives you a way to install as many Python interpreter versions as you want. And not just CPython ones, but others like PyPy, Pyston, and Stackless. You can really enjoy your options. And even though this part is really handy and superb, the next thing is even better. You can change the interpreter versions used on three different levels: global, local, and shell.</p>

<p>The global level is just the default interpreter version on your system. This way, whenever and wherever you type <code class="language-plaintext highlighter-rouge">python</code> in shell or run your project with <code class="language-plaintext highlighter-rouge">python main.py</code> you will use this specific version of the interpreter. You set this by executing <code class="language-plaintext highlighter-rouge">pyenv global &lt;version&gt;</code> in your shell.</p>

<p>Local level is even better because you set the interpreter version for the specific directory. This should be the project’s directory, so once you change your path to this project’s directory, the interpreter version used should be updated. The same interpreter version is set for all subdirectories. You can set this by executing <code class="language-plaintext highlighter-rouge">pyenv local &lt;version&gt;</code> in the shell, and you end up with <code class="language-plaintext highlighter-rouge">.python-version</code> file in the current directory, that specifies desired version.</p>

<p>Shell level is even more granular and sets the interpreter version just for the current shell that you are in. This is the least persistent setup because once you exit the shell and open it again, you end up with the interpreter version set up locally (if it is) or globally (which is set by default).</p>

<p>This makes your life a lot easier.</p>

<p>One more thing that is really handy is that you can manage virtual environments with <code class="language-plaintext highlighter-rouge">pyenv</code>. By having multiple interpreter versions and implementations, you are able to instantiate many virtual environments. These are installed at the specific system location set up by default. You can just write each down on a piece of paper and remember which project it belongs to, or you can just run <code class="language-plaintext highlighter-rouge">pyenv local &lt;virtual env name&gt;</code> in the project directory. This way, you get the automatic virtual environment activation once you position yourself in the project directory in shell.</p>

<p>In essence, <code class="language-plaintext highlighter-rouge">pyenv</code> solves 1.-4. points from the list given above. You could deal with the other two points for sure, but you would have to use additional tools. I see that <code class="language-plaintext highlighter-rouge">pyenv</code> was not created with that goal. And here we can slide into our next part.</p>

<h2 id="poetry">Poetry</h2>

<p>While <code class="language-plaintext highlighter-rouge">pyenv</code> gives the ability to manage different Python interpreter versions and many different virtual environments, <code class="language-plaintext highlighter-rouge">poetry</code> is good for managing package versions for each project (and virtual environment). <code class="language-plaintext highlighter-rouge">poetry</code> has its own way of managing virtual environments, which, in my opinion, should not be mixed with <code class="language-plaintext highlighter-rouge">pyenv</code> way.</p>

<p>Obviously, I will not be able to squeeze all of the information on how to use <code class="language-plaintext highlighter-rouge">poetry</code> here, but in general, it uses meta files that describe your project and specify versions of packages used. Or, to make it more eloquent, it is a tool to deal with dependency management in your project. Those who are seasoned developers can find this extremely important because of so-called <em>dependency hell</em>, while the newcomers will learn the importance of this very soon, if not already.</p>

<p>And while the user manual goes into depth describing how <code class="language-plaintext highlighter-rouge">poetry</code> can and should be used, it is interesting how it can be composed with <code class="language-plaintext highlighter-rouge">pyenv</code>. More precisely, my advice would be to use <code class="language-plaintext highlighter-rouge">pyenv</code> to make different Python interpreter versions available, and then use <code class="language-plaintext highlighter-rouge">poetry</code> to install a virtual environment for your project. Creating projects in <code class="language-plaintext highlighter-rouge">poetry</code> is as easy as running <code class="language-plaintext highlighter-rouge">poetry new &lt;project name&gt;</code>. From there you are able to install packages, update their versions, enter a virtual environment for easier interaction with the code, and so on.</p>

<p>Additionally, <code class="language-plaintext highlighter-rouge">poetry</code> gives you a way of structuring your project so you can publish it as a package/library. This way, it can be publicly available on PyPi or in private repositories.</p>

<p>Essentially, <code class="language-plaintext highlighter-rouge">poetry</code> solves the main points 2.-.6. So it’s almost all of them. This is why I think it is a good choice to use it with <code class="language-plaintext highlighter-rouge">pyenv</code> to achieve a smooth development process.</p>

<p>In the end, I want to make it clear that it is really up to you which set of tools you are going to use for your project, but you have to be aware of the scaling development process and make it smooth not just for you but for the whole team. You even have to make sure your project, which is going to be an integral part of some other project, is well structured with a logical package structure and good versioning. What could make your life easier as a contributor to a library could make library users lives harder. Have that in mind.</p>

<p>Anyway, have a nice day and share this blog post if you liked it!</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://realpython.com/intro-to-pyenv/#virtual-environments-and-pyenv">Managing Multiple Python Versions With pyenv</a></li>
  <li><a href="https://python-poetry.org/docs/">Python packaging and dependency management made easy</a></li>
</ul>]]></content><author><name>Ilija Lazarevic</name></author><category term="python" /><category term="software" /><category term="development" /><summary type="html"><![CDATA[The best complementary tools for managing virtual environments in Python development process]]></summary></entry><entry><title type="html">Is Python pass by value or pass by reference?</title><link href="https://ilijalazarevic.com/post-python-variable-passing/" rel="alternate" type="text/html" title="Is Python pass by value or pass by reference?" /><published>2023-07-10T14:21:28+02:00</published><updated>2023-07-10T14:21:28+02:00</updated><id>https://ilijalazarevic.com/post-python-variable-passing</id><content type="html" xml:base="https://ilijalazarevic.com/post-python-variable-passing/"><![CDATA[<p>This question is ubiquitous in all programming languages. Once you start using your programming language of choice for more than just simple programs and purposes, you will have to deal with more intermediate and advanced concepts. One of these is how function arguments are passed: by value or by reference?</p>

<p>Why is this something that is not that simple or easy to grasp? Well, you have to make sure you know what is happening with memory management once your program is running. Also, this certainly requires knowing the intricacies of language syntax and semantics. And if you have experience using lower-level languages like C or C++, you will know that similar questions bring a whole new level of advanced concepts like pointers, references, differences between them, and best practices for using them. It is not for the faint-hearted, I can tell you that.</p>

<p>Let’s start gently.</p>

<p>As a beginner, you may decide to define specific function for getting the circle circumference knowing the radius. And you may define it like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">circumference</span><span class="p">(</span><span class="n">radius</span><span class="p">):</span>
    <span class="c1"># let's keep it simple and use this value for PI
</span>    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span>  <span class="n">radius</span> <span class="o">*</span> <span class="mf">3.14</span>

</code></pre></div></div>

<p>Calling this function by passing the value for <code class="language-plaintext highlighter-rouge">radius</code> is easy and intuitive. You pass the value, and you get the result. What else is there to it?</p>

<p>Now, let’s say you want to count how many times you have called the function, by introducing the new variable <code class="language-plaintext highlighter-rouge">count</code> and passing it as the second argument of our function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">circumference</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="mf">3.14</span>
</code></pre></div></div>

<p>What would be the result of the function call?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n_calls</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">print</span><span class="p">(</span><span class="n">circumference</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_calls</span><span class="p">))</span>
<span class="c1"># 6.28
</span><span class="k">print</span><span class="p">(</span><span class="n">n_calls</span><span class="p">)</span>
<span class="c1"># 0
</span></code></pre></div></div>

<p>The circumference is correct, but what happened with <code class="language-plaintext highlighter-rouge">n_calls</code>? Why is it still 0, and not 1? Here the “pass by value or pass by reference?” question arises.</p>

<p>You probably already know that Python has one interesting function called <code class="language-plaintext highlighter-rouge">id</code> that returns the memory location of a variable. For example, we can redefine our function and print the memory location of the <code class="language-plaintext highlighter-rouge">count</code> variable:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">circumference</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Old count memory location:'</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'New count memory location:'</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="mf">3.14</span>
</code></pre></div></div>

<p>Now, we can print the memory location of our variable <code class="language-plaintext highlighter-rouge">n_calls</code> before we pass it to the function call, and the function will print the memory location of the <code class="language-plaintext highlighter-rouge">count</code> variable inside of it.</p>

<p>Before you try out this one, let’s make a thought experiment while introducing the concepts of <em>pass by value</em> and <em>pass by reference</em>.</p>

<p><strong>Pass by value</strong> means that each variable value that is passed as an argument in a function call is copied somewhere in computer memory, and that function argument name becomes the variable name that is assigned to it. This means that changing the value of this variable (<code class="language-plaintext highlighter-rouge">count</code> in our case) inside the function (value stored in a new memory location), doesn’t affect the value of the original variable (<code class="language-plaintext highlighter-rouge">n_calls</code>) value. How can we check if a new memory location is used for copying the variable value? <code class="language-plaintext highlighter-rouge">id</code> is our rescue.</p>

<p><strong>Pass by reference</strong> means that changing the value of a variable by using the name defined in the function declaration (<code class="language-plaintext highlighter-rouge">count</code>) affects the value of the original variable (<code class="language-plaintext highlighter-rouge">n_calls</code>). How can we check for this? Well, we already did with trying to modify <code class="language-plaintext highlighter-rouge">n_calls</code> by changing <code class="language-plaintext highlighter-rouge">count</code> inside our function. From the example, you can clearly see that Python doesn’t pass function argument variables by reference.</p>

<p>What is left for us is to try to make a proof that Python passes function argument variables by value, and we are done.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n_calls</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">n_calls</span><span class="p">))</span>
<span class="c1"># 140472497733840
</span><span class="k">print</span><span class="p">(</span><span class="n">circumference</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_calls</span><span class="p">))</span>
<span class="c1"># Old count memory location: 140472497733840
# New count memory location: 140472497733872
# 6.28
</span><span class="k">print</span><span class="p">(</span><span class="n">n_calls</span><span class="p">)</span>
<span class="c1"># 0
</span></code></pre></div></div>

<p>Alright, this is interesting. Apparently, it looks like the memory location of <code class="language-plaintext highlighter-rouge">count</code> is the same as the memory location of <code class="language-plaintext highlighter-rouge">n_calls</code>. This totally overrules our conclusion that Python passes by value because, in that case, memory locations would be different. Yet, when we change <code class="language-plaintext highlighter-rouge">count</code> in the function, it doesn’t update <code class="language-plaintext highlighter-rouge">n_calls</code> in the caller (outer scope). So it’s not passing a Python reference either. What kind of black magic are we witnessing here?</p>

<p>This is called <strong>passing by assignment</strong>. Yes, it does seem a bit odd because it sidetracks our initial question. And that question is perfectly valid for any programming language, at least the most widely used ones. So, what this mouthful of a statement means is that Python is passing by reference. Yet, when you use the same variable name in function local scope, this new name (reference) hides the one from the function argument. To go further, it hides the same variable name from any of the enclosing lexical scopes that exist in Python. So, the same variable name now references another object in memory.</p>

<p>How does this affects your options as a developer?</p>

<p>Well, if you want to achieve the effects of passing by reference, do not reassign the variable name to newly instantiated objects inside the function. What you can use is a mutable data structure, like a <code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">dict</code>, or custom-defined object, and update their state while keeping the reference intact. Example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">circumference</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Old count memory location:'</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
    <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'New count memory location:'</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="mf">3.14</span>

<span class="n">n_calls</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">n_calls</span><span class="p">))</span>
<span class="c1"># 140472420555968
</span><span class="k">print</span><span class="p">(</span><span class="n">circumference</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_calls</span><span class="p">))</span>
<span class="c1"># Old count memory location: 140472430829632
# New count memory location: 140472430829632
# 6.28
</span><span class="k">print</span><span class="p">(</span><span class="n">n_calls</span><span class="p">)</span>
<span class="c1"># [1]
</span></code></pre></div></div>

<p>This way, you keep the reference (name) to the object that was created by the caller and just update the object’s state. Pretty much the same can be achieved with a dictionary or custom object.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">circumference</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Old count memory location:'</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
    <span class="n">count</span><span class="p">[</span><span class="s">'calls'</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'New count memory location:'</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="mf">3.14</span>

<span class="n">n_calls</span> <span class="o">=</span> <span class="p">{</span><span class="s">'calls'</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">n_calls</span><span class="p">))</span>
<span class="c1"># 140472206558080
</span><span class="k">print</span><span class="p">(</span><span class="n">circumference</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_calls</span><span class="p">))</span>
<span class="c1"># Old count memory location: 140472206558080
# New count memory location: 140472206558080
# 6.28
</span><span class="k">print</span><span class="p">(</span><span class="n">n_calls</span><span class="p">)</span>
<span class="c1"># {'calls': 1}
</span></code></pre></div></div>

<p>I’ll leave you to do the experiment with custom objects.</p>

<p>Why was this so important? Well, I think that some concepts can be tricky to fully grasp, and not knowing them will eventually come back to bite you. In the best-case scenario, you will get the error at runtime, and you will know that something has to be fixed. The worst-case scenario is when everything runs smoothly but the error affects the business logic. These are <em>unknown unknowns</em>.</p>

<p>Check this out:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
    <span class="n">var</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">var</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>

<span class="k">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="c1"># (140472497734000, 140472497734032)
</span>
<span class="n">test</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># 140472497734000
# 140472497734032
# 6
</span></code></pre></div></div>

<p>What is happening here? I’ll probably write about this in some of my next blog posts.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">Stackoverflow - How do I pass a variable by reference?</a></li>
  <li><a href="https://realpython.com/python-pass-by-reference/">Pass by Reference in Python: Background and Best Practices</a></li>
</ul>]]></content><author><name>Ilija Lazarevic</name></author><category term="python" /><category term="software" /><category term="development" /><summary type="html"><![CDATA[Is Python pass by value or pass by reference?]]></summary></entry><entry><title type="html">Wholesome blog about daily digests</title><link href="https://ilijalazarevic.com/post-first-rant/" rel="alternate" type="text/html" title="Wholesome blog about daily digests" /><published>2023-07-07T07:14:21+02:00</published><updated>2023-07-07T07:14:21+02:00</updated><id>https://ilijalazarevic.com/post-first-rant</id><content type="html" xml:base="https://ilijalazarevic.com/post-first-rant/"><![CDATA[<p>As stated in the description of this blog post, I want to start sharing my work, snippets, adventures, and thoughts with you, yes you!</p>

<p>Well, I had an idea about putting up the poster of Uncle Sam, but.. heck, that would be too much. Let’s keep it quiet…er.</p>]]></content><author><name>Ilija Lazarevic</name></author><category term="me" /><summary type="html"><![CDATA[This is my first blog in a series about everything I do and part of what I think.]]></summary></entry></feed>